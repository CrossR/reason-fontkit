diff a/src/fontkit.cpp b/src/fontkit.cpp	(rejected hunks)
@@ -1,6 +1,7 @@
 #include <stdio.h>
 
 #include <caml/mlvalues.h>
+#include <caml/bigarray.h>
 #include <caml/memory.h>
 #include <caml/alloc.h>
 
@@ -52,32 +44,61 @@ extern "C" {
         CAMLreturn(error);
     }
 
+    double
+    convert_ft26_to_double(const long ft26_value) {
+        // printf("CP: converting %i to %f\n", ft26_value, ((double)ft26_value) / 64.0);
+        return ((double)ft26_value) / 64.0;
+    }
+
+    double
+    convert_ft16_to_double(const long ft16_value) {
+        // printf("CP: converting %i to %f\n", ft16_value, ((double)ft16_value) / 65536.0);
+        return ((double)ft16_value) / 65536.0;
+    }
+
+    value pixelModeToVariant(int pixelMode) {
+        switch(pixelMode) {
+        case FT_PIXEL_MODE_MONO:
+            return Val_int(0);
+        case FT_PIXEL_MODE_GRAY:
+            return Val_int(1);
+        case FT_PIXEL_MODE_LCD:
+            return Val_int(2);
+        case FT_PIXEL_MODE_LCD_V:
+            return Val_int(3);
+        case FT_PIXEL_MODE_BGRA:
+            return Val_int(4);
+        default:
+            printf("CP: Unexpected pixel mode");
+            return Val_int(0);
+        }
+    }
+
     /* Use native open type implementation to load font
       https://github.com/harfbuzz/harfbuzz/issues/255 */
     hb_font_t*
-    get_font_ot(const char *filename, int size)
-    {
-      FILE* file = fopen(filename, "rb");
-      fseek(file, 0, SEEK_END);
-      unsigned int length = ftell(file);
-      fseek(file, 0, SEEK_SET);
+    get_font_ot(const char *filename, int size) {
+        FILE* file = fopen(filename, "rb");
+        fseek(file, 0, SEEK_END);
+        unsigned int length = ftell(file);
+        fseek(file, 0, SEEK_SET);
 
-      char* data = (char *)malloc(length);
-      fread(data, length, 1, file);
-      fclose(file);
+        char* data = (char *)malloc(length);
+        fread(data, length, 1, file);
+        fclose(file);
 
-      hb_blob_t* blob = hb_blob_create(data, length, HB_MEMORY_MODE_WRITABLE, (void*)data, NULL);
-      hb_face_t* face = hb_face_create(blob, 0);
-      hb_font_t* font = hb_font_create(face);
+        hb_blob_t* blob = hb_blob_create(data, length, HB_MEMORY_MODE_WRITABLE, (void*)data, NULL);
+        hb_face_t* face = hb_face_create(blob, 0);
+        hb_font_t* font = hb_font_create(face);
 
-      hb_ot_font_set_funcs(font);
-      hb_font_set_scale(font, size, size);
+        hb_ot_font_set_funcs(font);
+        hb_font_set_scale(font, size, size);
 
-      return font;
+        return font;
     }
 
     CAMLprim value
-    caml_fk_new_face(value vString, value vInt)  {
+    caml_fk_new_face(value vString, value vInt) {
         CAMLparam2(vString, vInt);
         CAMLlocal1(ret);
 
@@ -104,53 +125,97 @@ extern "C" {
             hb_font_t *hb_font;
             hb_font = get_font_ot(szFont, iSize * 64);
 
-            FontKitFace* pFontKitFace = (FontKitFace *)malloc(sizeof(FontKitFace));
-            pFontKitFace->pFreeTypeFace = face;
-            pFontKitFace->pHarfbuzzFace = hb_font;
+            Face* pFace = (Face *)malloc(sizeof(Face));
+            pFace->pFreeTypeFace = face;
+            pFace->pHarfBuzzFace = hb_font;
 
-            ret = Val_success((value)pFontKitFace);
+            ret = Val_ok((value)pFace);
         }
         CAMLreturn(ret);
     }
 
     CAMLprim value
-    caml_fk_load_glyph(value vFace, value vGlyphId) {
+    caml_fk_render_glyph(value vFace, value vGlyphId) {
         CAMLparam2(vFace, vGlyphId);
-        CAMLlocal2(ret, record);
+        CAMLlocal5(returnValue, glyph, metrics, advance, bitmap);
+        CAMLlocal5(glyphBitmap, bitmapRows, bitmapWidth, bitmapPitch, bitmapBigarray);
+        CAMLlocal3(bitmapData, linearHorizontalAdvance, linearVerticalAdvance);
 
-        FontKitFace *pFontKitFace = (FontKitFace *)vFace;
+        Face *pFace = (Face *)vFace;
         long glyphId = Int_val(vGlyphId);
 
-        FT_Face face = *(pFontKitFace->pFreeTypeFace);
+        FT_Face face = *(pFace->pFreeTypeFace);
 
         if (FT_Load_Glyph(face, glyphId, FT_LOAD_RENDER)) {
-            ret = Val_error("[ERROR]: Unable to render character at FT_Load_Char\n");
+            returnValue = Val_error("[ERROR]: Unable to render character at FT_Load_Glyph\n");
         } else {
-            ReglfwImageInfo *p = (ReglfwImageInfo *)malloc(sizeof(ReglfwImageInfo));
-            p->numChannels = 1;
-            p->channelSize = 1;
-            p->width = face->glyph->bitmap.width;
-            p->height = face->glyph->bitmap.rows;
-
-            unsigned char *originalBuffer = face->glyph->bitmap.buffer;
-
-            int size = face->glyph->bitmap.width * face->glyph->bitmap.rows;
-            unsigned char* data = (unsigned char *)malloc(size);
-            memcpy(data, originalBuffer, size);
-
-            p->data = data;
-
-            record = caml_alloc(6, 0);
-            Store_field(record, 0, Val_int(p->width));
-            Store_field(record, 1, Val_int(p->height));
-            Store_field(record, 2, Val_int(face->glyph->bitmap_left));
-            Store_field(record, 3, Val_int(face->glyph->bitmap_top));
-            Store_field(record, 4, Val_int(face->glyph->advance.x));
-            Store_field(record, 5, (value)p);
-
-            ret = Val_success(record);
+            FT_Glyph_Metrics glyphMetrics = face->glyph->metrics;
+
+            // Since the metrics type only contains floats, it must be allocated as a float array
+            metrics = caml_alloc_float_array(8);
+            Store_double_field(metrics, 0, convert_ft26_to_double(glyphMetrics.width));
+            Store_double_field(metrics, 1, convert_ft26_to_double(glyphMetrics.height));
+            Store_double_field(metrics, 2, convert_ft26_to_double(glyphMetrics.horiBearingX));
+            Store_double_field(metrics, 3, convert_ft26_to_double(glyphMetrics.horiBearingY));
+            Store_double_field(metrics, 4, convert_ft26_to_double(glyphMetrics.horiAdvance));
+            Store_double_field(metrics, 5, convert_ft26_to_double(glyphMetrics.vertBearingX));
+            Store_double_field(metrics, 6, convert_ft26_to_double(glyphMetrics.vertBearingY));
+            Store_double_field(metrics, 7, convert_ft26_to_double(glyphMetrics.vertAdvance));
+
+            printf("CP: width: %li (%f)\n", glyphMetrics.width, Double_field(metrics, 0));
+            printf("CP: height: %li (%f)\n", glyphMetrics.height, Double_field(metrics, 1));
+            printf("CP: horizontalBearingX: %li (%f)\n", glyphMetrics.horiBearingX, Double_field(metrics, 2));
+            printf("CP: horizontalBearingY: %li (%f)\n", glyphMetrics.horiBearingY, Double_field(metrics, 3));
+            printf("CP: horizontalAdvance: %li (%f)\n", glyphMetrics.horiAdvance, Double_field(metrics, 4));
+            printf("CP: verticalBearingX: %li (%f)\n", glyphMetrics.vertBearingX, Double_field(metrics, 5));
+            printf("CP: verticalAdvance: %li (%f)\n", glyphMetrics.vertAdvance, Double_field(metrics, 6));
+
+            // Since the vector type only contains floats, it must be allocated as a float array
+            advance = caml_alloc_float_array(2);
+            Store_double_field(advance, 0, convert_ft26_to_double(face->glyph->advance.x));
+            Store_double_field(advance, 1, convert_ft26_to_double(face->glyph->advance.y));
+
+            printf("CP: advanceX: %li (%f)\n", face->glyph->advance.x, Double_field(advance, 0));
+            printf("CP: advanceY: %li (%f)\n", face->glyph->advance.x, Double_field(advance, 1));
+
+            FT_Bitmap bitmap = face->glyph->bitmap;
+            int bitmapDataLength = bitmap.rows * abs(bitmap.pitch);
+            bitmapData = caml_alloc_initialized_string(bitmapDataLength, (const char *)bitmap.buffer);
+            bitmapBigarray = caml_ba_alloc_dims(CAML_BA_UINT8 | CAML_BA_C_LAYOUT, 2, Bytes_val(bitmapData), abs(bitmap.pitch), bitmap.rows);
+
+            printf("CP: rows: %i\n", bitmap.rows);
+            printf("CP: width: %i\n", bitmap.width);
+            printf("CP: pitch: %i\n", bitmap.pitch);
+            printf("CP: pixelMode: %hhu\n", bitmap.pixel_mode);
+
+            glyphBitmap = caml_alloc(5, 0);
+            Store_field(glyphBitmap, 0, Val_int(bitmap.rows));
+            Store_field(glyphBitmap, 1, Val_int(bitmap.width));
+            Store_field(glyphBitmap, 2, Val_int(bitmap.pitch));
+            Store_field(glyphBitmap, 3, pixelModeToVariant(bitmap.pixel_mode));
+            Store_field(glyphBitmap, 4, bitmapBigarray);
+
+            linearHorizontalAdvance = caml_copy_double(convert_ft16_to_double(face->glyph->linearHoriAdvance));
+            linearVerticalAdvance = caml_copy_double(convert_ft16_to_double(face->glyph->linearVertAdvance));
+
+            printf("CP: linearHorizontalAdvance: %li (%f)\n", face->glyph->linearHoriAdvance, Double_val(linearHorizontalAdvance));
+            printf("CP: linearVerticalAdvance: %li (%f)\n", face->glyph->linearVertAdvance, Double_val(linearVerticalAdvance));
+            printf("CP: bitmapLeft: %i\n", face->glyph->bitmap_left);
+            printf("CP: bitmapTop: %i\n", face->glyph->bitmap_top);
+
+            glyph = caml_alloc(8, 0);
+            Store_field(glyph, 0, vFace);
+            Store_field(glyph, 1, metrics);
+            Store_field(glyph, 2, linearHorizontalAdvance);
+            Store_field(glyph, 3, linearVerticalAdvance);
+            Store_field(glyph, 4, advance);
+            Store_field(glyph, 5, glyphBitmap);
+            Store_field(glyph, 6, Val_int(face->glyph->bitmap_left));
+            Store_field(glyph, 7, Val_int(face->glyph->bitmap_top));
+
+            returnValue = Val_ok(glyph);
         }
-        CAMLreturn(ret);
+        CAMLreturn(returnValue);
     }
 
     static value createShapeTuple(unsigned int codepoint, unsigned int cluster) {
@@ -168,8 +233,8 @@ extern "C" {
         CAMLparam2(vFace, vString);
         CAMLlocal1(ret);
 
-        FontKitFace *pFontKitFace = (FontKitFace *)vFace;
-        hb_font_t *hb_font = pFontKitFace->pHarfbuzzFace;
+        Face *pFace = (Face *)vFace;
+        hb_font_t *hb_font = pFace->pHarfBuzzFace;
 
         hb_buffer_t* hb_buffer;
         hb_buffer = hb_buffer_create();
